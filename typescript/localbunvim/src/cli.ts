import apiInfo from "./apiInfo.json";

function toTypescriptType(type: string | undefined) {
    const typesMap: Record<string, string> = {
        Array: "any[]",
        "ArrayOf(Buffer)": "number[]",
        "ArrayOf(Dictionary)": "Record<string, any>[]",
        "ArrayOf(Integer)": "number[]",
        "ArrayOf(Integer, 2)": "[number, number]",
        "ArrayOf(String)": "string[]",
        "ArrayOf(Tabpage)": "number[]",
        "ArrayOf(Window)": "number[]",
        Boolean: "boolean",
        Buffer: "number",
        Dictionary: "Record<string, any>",
        Float: "number",
        Integer: "number",
        LuaRef: "any",
        Object: "any",
        String: "string",
        Tabpage: "number",
        void: "void",
        Window: "number",
    };
    const typescriptType = type && typesMap[type];
    if (!typescriptType) throw Error(`typescriptType for type: ${type} could not be termined`);
    return typescriptType;
}

let output = `/* eslint @typescript-eslint/no-explicit-any: 0 */
/* eslint @typescript-eslint/no-invalid-void-type: 0 */

/*
 * file generated by bunvim: https://github.com/gualcasas/bunvim
 */

export type NeovimApiInfo = {\n`;

apiInfo.functions
    .filter((fn) => fn.deprecated_since === undefined)
    .forEach((fun) => {
        output += `    ${fun.name}: {
        parameters: [${
            fun.parameters.length
                ? `${fun.parameters
                      .map((param) => `${param[1]}: ${toTypescriptType(param[0])}`)
                      .join(", ")}`
                : ""
        }];
        returns: ${toTypescriptType(fun.return_type)};
    };
`;
    });

output += "\n}";

await Bun.write("./src/neovim-api-info.ts", output);
